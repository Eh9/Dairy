# C++位操作

## 与

## 或

## 非

## 异或
异或运算符^,按位比较,相同为零,相异为一:
* 0^0=0
* 1^0=1 
* 1^1=0  
 

### 证明异或满足交换率和结合律:  
可以把xor看成是做+法以后再对2求余
所以  
1 xor 1 = (1 + 1) % 2 = 2 % 2 = 0  
0 xor 0 = (0 + 0) % 2 = 0 % 2 = 0  
0 xor 1 = (0 + 1) % 2 = 1 % 2 = 1  
1 xor 0 = (1 + 0) % 2 = 1 % 2 = 1  
所以xor的最后结果等于所有的operands按照原来的优先级加起来再对2求余  
因为加法本身是可交换可结合，所以间接的证明了xor也是可结合可交换的  




### 运用举例：
* 当A != B时,可以利用其来交换AB的值,只要这样
```
A ^= B
B ^= A
A ^= B
```  


* 1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现
  一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空
  间，能否设计一个算法实现？

  解法一、显然已经有人提出了一个比较精彩的解法，将所有数加起来，减去1+2+...+1000的和。
  这个算法已经足够完美了，相信出题者的标准答案也就是这个算法，唯一的问题是，如果数列过大，则可能会导致溢出。
  解法二、异或就没有这个问题，并且性能更好。
  将所有的数全部异或，得到的结果与1^2^3^...^1000的结果进行异或，得到的结果就是重复数。

  但是这个算法虽然很简单，但证明起来并不是一件容易的事情。这与异或运算的几个特性有关系。
  首先是异或运算满足交换律、结合律。
  所以，1^2^...^n^...^n^...^1000，无论这两个n出现在什么位置，都可以转换成为1^2^...^1000^(n^n)的形式。

  其次，对于任何数x，都有x^x=0，x^0=x。
  所以1^2^...^n^...^n^...^1000 = 1^2^...^1000^(n^n)= 1^2^...^1000^0 = 1^2^...^1000（即序列中除了n的所有数的异或）。

  令，1^2^...^1000（序列中不包含n）的结果为T
  则1^2^...^1000（序列中包含n）的结果就是T^n。
  T^(T^n)=n。
  所以，将所有的数全部异或，得到的结果与1^2^3^...^1000的结果进行异或，得到的结果就是重复数。

  当然有人会说，1+2+...+1000的结果有高斯定律可以快速计算，但实际上1^2^...^1000的结果也是有规律的，算法比高斯定律还该简单的多。
